class Solution {
    public int minFlips(int[][] mat) {
        // Instantiate initial config with zero steps
        Config init = new Config(mat, 0);
        if (init.isDone()) {
            return init.step;
        }
        
        // configs seen so far
        Set<String> visited = new HashSet<>();
        visited.add( init.toString());
        
        // BFS
        Queue<Config> q = new LinkedList<>();
        q.add(init);
        while(!q.isEmpty()) {
            Config c = q.poll();
            for(Config next: c.getNeighbours()) { // all configs generated by flipping once
                String nextStr = next.toString();
                if (!visited.contains(nextStr)) { // unvisited
                    if (next.isDone()) // reached solution
                        return next.step;
                    visited.add(nextStr);
                    q.add(next);
                }
            }
        }
        return -1; // not possible to reach destination from source
    } 
    
    // Internal class to represent matrix config
    class Config {
        int[][] mat;
        int rows;
        int cols;
        int step; // number of steps taken to generate current config from initial matrix
        
        // constructor
        Config(int[][] mat, int step) {
            this.mat = mat;
            rows = mat.length;
            cols = mat[0].length;
            this.step = step;
        }
        
        // check if matrix is zero matrix
        private boolean isDone() {
            for (int i=0; i<mat.length; i++) {
                for (int val : mat[i])
                    if (val != 0)
                        return false;
            }
            return true;
        }
        
        // generate all (m*n) possible configs by flipping ONCE in current matrix
        public List<Config> getNeighbours() {
            List<Config> neighbours = new ArrayList<>();
            for (int i=0; i<rows; i++)
                for(int j=0; j<cols; j++)
                    neighbours.add(flip(i, j));
            return neighbours;
        }
        
        // next config by flipping value at (row,col) position (and neighbours)
        private Config flip(int row, int col) {
            // create a new copy of matrix
            int[][] next = new int[rows][cols];
            for (int i = 0; i < rows; i++) {
				for (int j = 0; j < cols; j++) {
					if ((i == row && j == col) || (i == row && j == col+1) || (i == row+1 && j == col) ||
						(i == row && j == col-1) || (i == row-1 && j == col))
						next[i][j] = 1 - mat[i][j];
					else
						next[i][j] = mat[i][j];
				}
			}

            // increment step by one in resultant matrix 
            return new Config(next, step+1);
        }
		
		// generate string of 0s and 1s to represent matrix
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            for (int i=0; i<rows; i++) {
                for (int num: mat[i])
                    sb.append(num);
            }
            return sb.toString();
        }
    }  
}